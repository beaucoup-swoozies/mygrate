// Generated by CoffeeScript 1.3.1
(function() {
  var Fs, Path, async, dbInterface, down, ensureDirs, getSubDirs, pad2, prog, readMigrationFile, timestamp,
    _this = this;

  Fs = require("fs");

  Path = require("path");

  prog = require("commander");

  async = require("async");

  dbInterface = function() {
    var Postgresql, config, env;
    Postgresql = require("./postgresql");
    env = process.env.NODE_ENV || "development";
    config = require(process.cwd() + "/migrations/config")[env];
    return {
      connectionInfo: config.postgresql,
      schema: new Postgresql(config.postgresql)
    };
  };

  pad2 = function(num) {
    var out;
    out = "";
    if (num < 9) {
      out += "0";
    }
    return out + num;
  };

  timestamp = function(date, separator) {
    if (date == null) {
      date = new Date();
    }
    if (separator == null) {
      separator = " ";
    }
    return [date.getUTCFullYear(), pad2(date.getUTCMonth() + 1), pad2(date.getUTCDate()), pad2(date.getUTCHours()), pad2(date.getUTCMinutes())].join(separator);
  };

  ensureDirs = function() {
    if (!Path.existsSync("./migrations")) {
      Fs.mkdirSync("./migrations");
      console.log("`migrations` directory created");
    }
    if (!Path.existsSync("./migrations/config.js")) {
      Fs.writeFileSync("./migrations/config.js", "module.exports = {\n  development: {\n    postgresql: \"tcp://USER:PASSWORD@HOST/DB\"\n  },\n  test: {\n    postgresql: \"tcp://USER:PASSWORD@HOST/DB\"\n  },\n  production: {\n    postgresql: \"tcp://USER:PASSWORD@HOST/DB\"\n  },\n};");
      return console.log("`migrations/config.js` created. Requires editing.");
    }
  };

  getSubDirs = function(dirname, cb) {
    var dirs, fifiles, file, stat, _i, _len, _ref;
    dirname = Path.resolve(dirname);
    dirs = [];
    fifiles = Fs.readdirSync(dirname);
    _ref = Fs.readdirSync(dirname);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      file = _ref[_i];
      stat = Fs.statSync(dirname + "/" + file);
      if (stat.isDirectory()) {
        dirs.push(file);
      }
    }
    return cb(null, dirs);
  };

  readMigrationFile = function(migration, which) {
    var filename;
    filename = "migrations/" + migration + "/" + which + ".sql";
    return Fs.readFileSync(filename, "utf8");
  };

  down = function(schema, migrations, cb) {
    return async.forEachSeries(migrations, function(version, cb) {
      down = readMigrationFile(version, "down");
      return schema.exec(down, function(err) {
        if (err) {
          return cb("Down `migrations/" + version + "`: " + err);
        }
        return schema.remove(version, function(err) {
          if (err) {
            return cb("Down `migrations/" + version + "`: " + err);
          }
          console.log("Down `migrations/" + version + "` OK");
          return cb(null);
        });
      });
    }, cb);
  };

  module.exports = {
    generate: function(suffix) {
      var filename, path;
      ensureDirs();
      filename = timestamp();
      if (typeof suffix === "string") {
        filename += "-" + suffix;
      }
      path = "./migrations/" + filename;
      if (!Path.existsSync(path)) {
        Fs.mkdirSync(path);
        Fs.writeFileSync(path + "/up.sql", "");
        Fs.writeFileSync(path + "/down.sql", "");
        return console.log("Migration files created: " + path);
      }
    },
    migrateUp: function() {
      var dirs, lastMigration, schema;
      schema = dbInterface().schema;
      dirs = null;
      lastMigration = null;
      return async.series({
        ensureSchema: function(cb) {
          return schema.init(cb);
        },
        getMigrationDirs: function(cb) {
          return getSubDirs("migrations", function(err, subdirs) {
            if (err) {
              return cb(err);
            }
            dirs = subdirs.sort();
            return cb(null);
          });
        },
        getLastMigration: function(cb) {
          return schema.last(function(err, migration) {
            lastMigration = migration;
            return cb(err);
          });
        },
        run: function(cb) {
          var index, msg, versions;
          if (lastMigration != null ? lastMigration.version : void 0) {
            index = dirs.indexOf(lastMigration.version);
            versions = dirs.slice(index + 1);
          } else {
            versions = dirs;
          }
          if (versions.length > 0) {
            return async.forEachSeries(versions, function(version, cb) {
              var up;
              up = readMigrationFile(version, "up");
              down = readMigrationFile(version, "down");
              return schema.add(version, up, down, function(err) {
                if (err) {
                  return cb(err);
                }
                return schema.exec(up, function(err) {
                  if (err) {
                    return cb("Up `migrations/" + version + "`: " + err);
                  } else {
                    console.log("Up `migrations/" + version + "` OK");
                    return cb(null);
                  }
                });
              });
            }, cb);
          } else {
            msg = "Nothing to run.";
            if (lastMigration != null ? lastMigration.version : void 0) {
              msg += " Last recorded migration: migrations/" + lastMigration.version;
            }
            console.log(msg);
            return cb(null);
          }
        }
      }, function(err) {
        if (err) {
          console.error(err);
        }
        return process.exit();
      });
    },
    migrateDown: function(countOrVersion) {
      var dirs, lastMigration, schema;
      schema = dbInterface().schema;
      if (typeof countOrVersion !== "string") {
        countOrVersion = "1";
      }
      dirs = null;
      lastMigration = null;
      return async.series({
        getMigrationDirs: function(cb) {
          return getSubDirs("migrations", function(err, subdirs) {
            if (err) {
              return cb(err);
            }
            dirs = subdirs;
            return cb(null);
          });
        },
        getLastMigration: function(cb) {
          return schema.last(function(err, migration) {
            if (err) {
              return cb(err);
            }
            lastMigration = migration;
            return cb(err);
          });
        },
        run: function(cb) {
          return schema.all(function(err, migrations) {
            var count, found, migration, version, versions, _i, _j, _len, _len1;
            if (err) {
              return cb(err);
            }
            versions = [];
            if (countOrVersion.length < 3) {
              count = parseInt(countOrVersion);
              for (_i = 0, _len = migrations.length; _i < _len; _i++) {
                migration = migrations[_i];
                versions.push(migration.version);
                count -= 1;
                if (count === 0) {
                  break;
                }
              }
              return down(schema, versions, cb);
            } else {
              version = countOrVersion;
              versions = [];
              for (_j = 0, _len1 = migrations.length; _j < _len1; _j++) {
                migration = migrations[_j];
                versions.push(migration.version);
                if (migration.version === version) {
                  found = migration;
                  break;
                }
              }
              if (found) {
                return down(schema, versions, cb);
              } else {
                return cb(null);
              }
            }
          });
        }
      }, function(err) {
        if (err) {
          console.error(err);
        }
        return process.exit();
      });
    },
    history: function() {
      var connectionInfo, schema, _ref;
      _ref = dbInterface(), connectionInfo = _ref.connectionInfo, schema = _ref.schema;
      return schema.all(function(err, migrations) {
        var at, migration, _i, _len;
        if (err) {
          return cb(err);
        }
        console.log("History connection=" + JSON.stringify(connectionInfo));
        for (_i = 0, _len = migrations.length; _i < _len; _i++) {
          migration = migrations[_i];
          at = timestamp(new Date(migration.created_at), "-");
          console.log("" + at + "\t" + migration.version);
        }
        return process.exit();
      });
    }
  };

}).call(this);
