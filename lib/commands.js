// Generated by CoffeeScript 1.6.3
(function() {
  var Commands, Fs, Os, Path, Table, Utils, async, cwd, dbInterface, down, errHandler, existsSync, forceDown, getSubDirs, initMigrationsDir, migrationFile, pad2, readMigrationFile, timestamp,
    _this = this;

  Fs = require("fs");

  Path = require("path");

  async = require("async");

  Utils = require("./utils");

  Table = require("cli-table");

  Os = require("os");

  existsSync = Fs.existsSync ? Fs.existsSync : Path.existsSync;

  cwd = process.cwd();

  errHandler = function(err) {
    if (err) {
      return console.error(err);
    } else {
      console.log("OK");
      return process.exit(1);
    }
  };

  dbInterface = function() {
    var Adapter, adapter, config, env, v, _ref, _ref1;
    if (!existsSync("migrations")) {
      console.error("migrations directory not found");
      process.exit(1);
    }
    env = process.env.NODE_ENV || "development";
    config = require(process.cwd() + "/migrations/config")[env];
    for (adapter in config) {
      v = config[adapter];
      if (adapter === "mygrate") {
        continue;
      }
      Adapter = require("./" + adapter);
      break;
    }
    return {
      config: config[adapter],
      minHookDate: (_ref = (_ref1 = config.mygrate) != null ? _ref1.minHookDate : void 0) != null ? _ref : "999999999999",
      schema: new Adapter(config[adapter])
    };
  };

  pad2 = function(num) {
    if (num < 10) {
      return "0" + num;
    } else {
      return num;
    }
  };

  timestamp = function(date, separator) {
    if (date == null) {
      date = new Date();
    }
    if (separator == null) {
      separator = "";
    }
    return [date.getUTCFullYear(), pad2(date.getUTCMonth() + 1), pad2(date.getUTCDate()), pad2(date.getUTCHours()), pad2(date.getUTCMinutes())].join(separator);
  };

  initMigrationsDir = function(vendor, config) {
    if (!existsSync("./migrations")) {
      Fs.mkdirSync("./migrations");
    }
    if (!existsSync("./migrations/config.js")) {
      Fs.writeFileSync("./migrations/config.js", config);
      return console.log("Created " + vendor + " sample configuration. Edit migrations/config.js.");
    }
  };

  getSubDirs = function(dirname, cb) {
    var dirs, fifiles, file, stat, _i, _len, _ref;
    dirname = Path.resolve(dirname);
    dirs = [];
    fifiles = Fs.readdirSync(dirname);
    _ref = Fs.readdirSync(dirname);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      file = _ref[_i];
      stat = Fs.statSync(dirname + "/" + file);
      if (stat.isDirectory()) {
        dirs.push(file);
      }
    }
    return cb(null, dirs);
  };

  migrationFile = function(version, which) {
    return Path.resolve("migrations/" + version + "/" + which + ".sql");
  };

  readMigrationFile = function(migration, which) {
    var filename;
    filename = migrationFile(migration, which);
    if (existsSync(filename)) {
      return Fs.readFileSync(filename, "utf8");
    } else {
      return "";
    }
  };

  down = function(schema, migrations, cb) {
    var migrate;
    migrate = function(version, cb) {
      var filename;
      filename = migrationFile(version, "down");
      return schema.execFile(filename, function(err) {
        if (err) {
          return cb("Down migrations/" + version + ": " + err);
        }
        return schema.remove(version, function(err) {
          if (err) {
            return cb("Down migrations/" + version + ": " + err);
          }
          console.log("Down migrations/" + version);
          return cb(null);
        });
      });
    };
    return async.forEachSeries(migrations, migrate, cb);
  };

  forceDown = function(schema, version, cb) {
    var filename;
    filename = migrationFile(version, "down");
    return schema.execFile(filename, cb);
  };

  Commands = {
    "console": function() {
      var schema;
      schema = dbInterface().schema;
      return schema.console();
    },
    generate: function(suffix, options) {
      var filename, path;
      if (!existsSync(Path.resolve("migrations"))) {
        console.error("ERROR migrations directory not found. Try `mygrate init`");
        process.exit(1);
      }
      if (typeof suffix !== "string") {
        console.error("Migration identifier missing");
        process.exit(1);
      }
      filename = timestamp();
      if (typeof suffix === "string") {
        filename += "-" + suffix;
      }
      path = "./migrations/" + filename;
      if (!existsSync(path)) {
        Fs.mkdirSync(path);
        Fs.writeFileSync(path + "/up.sql", "");
        Fs.writeFileSync(path + "/down.sql", "");
        return console.log("Migration created: " + path);
      }
    },
    init: function(vendor) {
      var config, name;
      if (['mysql', 'postgresql'].indexOf(vendor) < 0) {
        vendor = "postgresql";
      }
      name = Path.basename(process.cwd()).replace(/\W/g, "_");
      switch (vendor) {
        case 'mysql':
          config = "module.exports = {\n  development: {\n    mysql: {\n      host: \"localhost\",\n      database: \"" + name + "_dev\",\n      user: \"" + name + "_dev_user\",\n      password: \"dev\",\n      port: 3306\n    }\n  },\n  test: {\n    mysql: {\n      host: \"localhost\",\n      database: \"" + name + "_test\",\n      user: \"" + name + "_test_user\",\n      password: \"test\",\n      port: 3306\n    }\n  },\n  production: {\n    mysql: {\n      host: \"localhost\",\n      database: \"" + name + "_prod\",\n      user: \"" + name + "_prod_user\",\n      password: \"prod\",\n      port: 3306\n    }\n  }\n};";
          break;
        case 'postgres':
        case 'postgresql':
          config = "module.exports = {\n  development: {\n    postgresql: {\n      host: \"localhost\",\n      database: \"" + name + "_dev\",\n      user: \"" + name + "_dev_user\",\n      password: \"dev\"\n    }\n  },\n  test: {\n    postgresql: {\n      host: \"localhost\",\n      database: \"" + name + "_test\",\n      user: \"" + name + "_test_user\",\n      password: \"test\"\n    }\n  },\n  production: {\n    postgresql: {\n      host: \"localhost\",\n      database: \"" + name + "_prod\",\n      user: \"" + name + "_prod_user\",\n      password: \"prod\"\n    }\n  }\n};\n";
      }
      initMigrationsDir(vendor, config);
      return Commands.generate("init");
    },
    migrateUp: function(argv) {
      var config, dirs, lastMigration, minHookDate, schema, _ref;
      _ref = dbInterface(), schema = _ref.schema, config = _ref.config, minHookDate = _ref.minHookDate;
      dirs = null;
      lastMigration = null;
      return async.series({
        ensureSchema: function(cb) {
          return schema.init(cb);
        },
        getMigrationDirs: function(cb) {
          return getSubDirs("migrations", function(err, subdirs) {
            if (err) {
              return cb(err);
            }
            dirs = subdirs.sort();
            return cb(null);
          });
        },
        getLastMigration: function(cb) {
          return schema.last(function(err, migration) {
            lastMigration = migration;
            return cb(err);
          });
        },
        run: function(cb) {
          var index, migrateUp, msg, versions;
          if (lastMigration != null ? lastMigration.version : void 0) {
            index = dirs.indexOf(lastMigration.version);
            versions = dirs.slice(index + 1);
          } else {
            versions = dirs;
          }
          if (versions.length > 0) {
            migrateUp = function(version, cb) {
              return async.series({
                prehook: function(cb) {
                  var filename;
                  filename = Path.resolve("migrations/" + version + "/prehook");
                  if (existsSync(filename)) {
                    timestamp = version.slice(0, 12);
                    if (minHookDate > timestamp) {
                      console.log("Skipping " + version + "/prehook");
                      return cb();
                    }
                    console.log("Running " + version + "/prehook");
                    return Utils.spawn(filename, [], {
                      cwd: Path.dirname(filename)
                    }, cb);
                  } else {
                    return cb();
                  }
                },
                upscript: function(cb) {
                  var filename;
                  filename = migrationFile(version, "up");
                  return schema.execFile(filename, function(err) {
                    var up;
                    if (err) {
                      return cb("Up migrations/" + version + ": exit code " + err);
                    }
                    up = readMigrationFile(version, "up");
                    down = readMigrationFile(version, "down");
                    return schema.add(version, up, down, function(err) {
                      if (err) {
                        return cb(err);
                      }
                      console.log("Up migrations/" + version);
                      return cb(null);
                    });
                  });
                }
              }, cb);
            };
            return async.forEachSeries(versions, migrateUp, cb);
          } else {
            msg = "Nothing to run.";
            if (lastMigration != null ? lastMigration.version : void 0) {
              msg += " Last recorded migration: migrations/" + lastMigration.version;
            }
            console.log(msg);
            return cb(null);
          }
        }
      }, function(err) {
        var errFile;
        if (err) {
          errFile = err.toString().match(/migrations\/([^:]+):/);
          if (errFile) {
            errFile = errFile[1];
            Fs.writeFileSync("migrations/errfile", errFile);
          }
          console.error(err);
          return process.exit(1);
        } else {
          if (existsSync("migrations/errfile")) {
            Fs.unlinkSync("migrations/errfile");
          }
          console.log("OK");
          return process.exit();
        }
      });
    },
    migrateDown: function(countOrVersion) {
      var dirs, lastMigration, schema;
      schema = dbInterface().schema;
      if (typeof countOrVersion !== "string") {
        countOrVersion = "1";
      }
      dirs = null;
      lastMigration = null;
      return async.series({
        getLastMigration: function(cb) {
          return schema.last(function(err, migration) {
            if (err) {
              return cb(err);
            }
            lastMigration = migration;
            return cb(err);
          });
        },
        getMigrationDirs: function(cb) {
          return getSubDirs("migrations", function(err, subdirs) {
            if (err) {
              return cb(err);
            }
            dirs = subdirs;
            return cb(null);
          });
        },
        run: function(cb) {
          return schema.all(function(err, migrations) {
            var count, found, migration, version, versions, _i, _j, _k, _len, _len1, _len2;
            if (err) {
              return cb(err);
            }
            if (countOrVersion === "1") {
              if (existsSync("migrations/errfile")) {
                version = Fs.readFileSync("migrations/errfile", "utf8");
                console.log("Trying to recover from " + version + " error");
                return forceDown(schema, version, function(err) {
                  if (!err) {
                    Fs.unlinkSync("migrations/errfile");
                  }
                  return cb(err);
                });
              }
            }
            if (migrations.length === 0) {
              console.log("0 migrations found");
              return cb(null);
            }
            versions = [];
            if (countOrVersion === "all") {
              for (_i = 0, _len = migrations.length; _i < _len; _i++) {
                migration = migrations[_i];
                versions.push(migration.version);
              }
              return down(schema, versions, cb);
            } else if (countOrVersion.length < 3) {
              count = parseInt(countOrVersion);
              for (_j = 0, _len1 = migrations.length; _j < _len1; _j++) {
                migration = migrations[_j];
                versions.push(migration.version);
                count -= 1;
                if (count === 0) {
                  break;
                }
              }
              return down(schema, versions, cb);
            } else {
              version = countOrVersion;
              versions = [];
              for (_k = 0, _len2 = migrations.length; _k < _len2; _k++) {
                migration = migrations[_k];
                versions.push(migration.version);
                if (migration.version === version) {
                  found = migration;
                  break;
                }
              }
              if (found) {
                return down(schema, versions, cb);
              } else {
                return cb(null);
              }
            }
          });
        }
      }, function(err) {
        if (err) {
          console.error(err);
          return process.exit(1);
        } else {
          console.log("OK");
          return process.exit();
        }
      });
    },
    printConfig: function(config) {
      var s;
      s = "Connection: ";
      s += config.user;
      s += "@" + config.host;
      if (config.port) {
        s += ":" + config.port;
      }
      if (config.database) {
        s += "/" + config.database;
      }
      return console.log(s);
    },
    history: function() {
      var config, schema, _ref;
      _ref = dbInterface(), config = _ref.config, schema = _ref.schema;
      return schema.all(function(err, migrations) {
        var at, migration, table, _i, _len;
        if (err) {
          console.error(err);
          process.exit(1);
        }
        Commands.printConfig(config);
        if (migrations.length < 1) {
          console.log("0 migrations found");
        } else {
          table = new Table({
            head: ["migrated at", "script set"],
            chars: {
              'top': '',
              'top-mid': '',
              'top-left': '',
              'top-right': '',
              'bottom': '',
              'bottom-mid': '',
              'bottom-left': '',
              'bottom-right': '',
              'left': '',
              'left-mid': '',
              'mid': '',
              'mid-mid': '',
              'right': '',
              'right-mid': '',
              'middle': ' '
            }
          });
          for (_i = 0, _len = migrations.length; _i < _len; _i++) {
            migration = migrations[_i];
            at = timestamp(new Date(migration.created_at), "-");
            table.push([at, migration.version]);
          }
          console.log(table.toString());
        }
        return process.exit();
      });
    },
    createDatabase: function() {
      var defaultUser, platform, schema;
      schema = dbInterface().schema;
      platform = Os.platform();
      if (platform.match(/^darwin/)) {
        defaultUser = process.env.USER;
      } else {
        defaultUser = 'postgres';
      }
      return schema.createDatabase(defaultUser);
    },
    execFile: function(filename) {
      var schema;
      if (typeof filename !== 'string') {
        return errHandler('Filename required');
      }
      filename = Path.resolve(filename);
      schema = dbInterface().schema;
      return schema.execFile(filename, errHandler);
    }
  };

  module.exports = Commands;

}).call(this);
